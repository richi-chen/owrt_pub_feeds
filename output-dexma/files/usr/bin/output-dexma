#!/usr/bin/lua
--[[
    Karl Palsson, 2017 <karlp@etactica.com>
]]

-- todo - cjson, or luci-lua-jsonc maybe?
local json = require("dkjson")
local mosq = require("mosquitto")
-- nonideal, but ok.
local ugly = require("remake.ugly_log")

local socket = require "socket"
local https = require("ssl.https")
local ltn12 = require("ltn12")

local Puni = require("posix.unistd")
local pl = require'pl.import_into'()

local function sleep(ms)
    socket.select(nil, nil, ms / 1000)
end

local args = pl.lapp [[
  Basic output to dexma
  if key_file is provided, the environment var is ignored.
  the name of the environment var can be changed to allow multiple instances.
    -H,--host (default "localhost") MQTT host to listen to
    -i,--id (string) identifier for dexma
    -k,--key (default "DEXMA_KEY") environment variable or file containing private key
    -f,--key_is_file using this means that -k refers to a file, not an env var
    -v,--verbose (0..7 default 4) Logging level, higher == more
]]

local cfg = {
    APP_NAME = "output-dexma",
    MOSQ_CLIENT_ID = string.format("output-dexma-%d", Puni.getpid()),
    --MOSQ_CLIENT_ID = string.format("output-dexma-%d", 123),
    TOPIC_LISTEN = "status/local/json/device/#",
    TEMPLATE_POST_URL = "https://requestb.in/zeq97sze?source_key=%s",
    POST_INTERVAL = 10, -- once a minute is enough...
}

local cache = {}

ugly.initialize(cfg.APP_NAME, args.verbose or 4)

if args.key_is_file then
	ugly.debug("looking at file... %s", args.key)
	if pl.path.isfile(args.key) then
		args.key = pl.stringx.strip(pl.file.read(args.key))
	else
		pl.utils.quit(1, "key file specified does not exist: %s", args.key)
	end
else
	ugly.debug("looking at envvar... %s", args.key)
	args.key = os.getenv(args.key)
end
if not args.key then
	pl.utils.quit(1, "key must be provided by either environment or file")
end
ugly.debug("Operating with private key: <%s>", args.key)

mosq.init()
local mqtt = mosq.new(cfg.MOSQ_CLIENT_ID, true)

for i = 1,3 do
    local rv = mqtt:connect(args.host, 1883, 60)
    if rv then
	ugly.notice("MQTT Connected to: %s", args.host)
        break
    else
        ugly.notice("Failed to connect, retrying...")
	sleep(500)
    end
end

if not mqtt:subscribe(cfg.TOPIC_LISTEN, 0) then
    -- We are not connected, just abort here and let things restart us
    ugly.err("Aborting, unable to make MQTT connection to: %s", args.host)
    os.exit(1)
end

mqtt.ON_MESSAGE = function(mid, topic, jpayload, qos, retain)
    local payload, err = json.decode(jpayload)
    local devid = pl.stringx.split(topic, "/")[5]
    if not payload then
        ugly.warning("Invalid json in message on topic: %s, %s", topic, err)
        return
    end
    if not payload.hwc or not payload.phases then
        ugly.notice("Ignoring unsuitable json format on topic: %s", topic);
        return
    end
    if payload.error then ugly.notice("Ignoring failed reading"); return end
    if payload.hwc.typeOfMeasurementPoints == "cbms" then ugly.debug("Ignoring bar reading"); return end

    cache[devid] = {
	ts=payload.timestamp_ms,
	kwh = payload.cumulative_wh/1000,
    }
    --cache.volts = payload.phases[1].voltage
    --cache.amps = payload.phases[1].current
    --cache.pf = payload.phases[1].pf
    --cache.kwh = payload.cumulative_wh / 1000
end

mqtt:loop_start()

---[[
--data table to be json encoded and posted
local function httppost(data)
	local respbody = {}
	local reqbody = json.encode(data)
	ugly.debug("posting now: %s", reqbody)
	url = string.format(cfg.TEMPLATE_POST_URL, args.id),
	print("url used is ", url, "my id is", args.id)
       	headers = {
		["x-dexcell-source-token"] = args.key,
		["Content-Type"] = "application/json;charset=utf-8",
		["content-length"] = #reqbody,
	}
	local r,c,h = https.request {
        	method = "POST",
		url = url,
        	source = ltn12.source.string(reqbody),
        	headers = headers,
        	sink = ltn12.sink.table(respbody),
	}
	local real_resp = table.concat(respbody)
	print("real resp = ", real_resp)
	print("code = ", c)
	print("headers = ", pl.pretty.write(h))
	return real_resp, c, h

end


local function process_cache(cache)
        if pl.tablex.size(cache) == 0 then
		ugly.debug("Skipping post, no data in cache")
		return
	end
	local data = {}

	for i,v in pairs(cache) do
		local entry = {
			did = i,
			sqn = 1,
			ts = os.date('%Y-%m-%dT%H:%M:%SZ', math.ceil(v.ts/1000)),
			values = {
				{p=402, v=v.kwh}
			}
		}
		table.insert(data, entry)
	end
	
	print(httppost(data))
end

while true do
	process_cache(cache)
    	sleep(cfg.POST_INTERVAL * 1000)
end

